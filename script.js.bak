const startButton = document.getElementById('start-button');
const nextButton = document.getElementById('next-button');
const restartButton = document.getElementById('restart-button');
const reviewButton = document.getElementById('review-button');
const reviewPrevButton = document.getElementById('review-prev');
const reviewNextButton = document.getElementById('review-next');
const reviewExitButton = document.getElementById('review-exit');
const startScreen = document.getElementById('start-screen');
const quizScreen = document.getElementById('quiz-screen');
const resultScreen = document.getElementById('result-screen');
const reviewScreen = document.getElementById('review-screen');
const questionContainerElement = document.getElementById('question-container');
const questionElement = document.getElementById('question');
const answerButtonsElement = document.getElementById('answer-buttons');
const scoreElement = document.getElementById('score');
const reviewQuestionElement = document.getElementById('review-question');
const reviewAnswersElement = document.getElementById('review-answers');
const reviewCounterElement = document.getElementById('review-counter');
// Nuovi riferimenti per progresso e notifiche accessibili
const progressText = document.getElementById('progress-text');
const notificationRegion = document.getElementById('notification-region');

let allQuestions = [];
let selectedQuestions = []; // Nuovo array per le domande selezionate
let currentQuestionIndex;
let score = 0;
let userAnswers = []; // Array per tracciare le risposte dell'utente
let reviewIndex = 0; // Indice per la modalit√† revisione

// Funzioni per la gestione del localStorage
const QuizState = {
    save: function() {
        try {
            const state = {
                selectedQuestions,
                currentQuestionIndex,
                score,
                userAnswers,
                timestamp: Date.now()
            };
            localStorage.setItem('quiz-dialetti-state', JSON.stringify(state));
        } catch (e) {
            console.warn('Impossibile salvare lo stato del quiz:', e);
        }
    },
    
    load: function() {
        try {
            const saved = localStorage.getItem('quiz-dialetti-state');
            if (saved) {
                const state = JSON.parse(saved);
                // Controlla se lo stato √® recente (max 1 ora)
                if (Date.now() - state.timestamp < 3600000) {
                    return state;
                }
            }
        } catch (e) {
            console.warn('Impossibile caricare lo stato del quiz:', e);
        }
        return null;
    },
    
    clear: function() {
        try {
            localStorage.removeItem('quiz-dialetti-state');
        } catch (e) {
            console.warn('Impossibile cancellare lo stato del quiz:', e);
        }
    }
};

// Sostituzione funzione showNotification con versione accessibile
function showNotification(message, type = 'info') {
    if (notificationRegion) {
        notificationRegion.textContent = message;
    }
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.setAttribute('role', type === 'error' ? 'alert' : 'status');
    const span = document.createElement('span');
    span.textContent = message;
    const closeBtn = document.createElement('button');
    closeBtn.setAttribute('aria-label', 'Chiudi notifica');
    closeBtn.textContent = '√ó';
    closeBtn.addEventListener('click', () => notification.remove());
    notification.appendChild(span);
    notification.appendChild(closeBtn);
    document.body.appendChild(notification);
    setTimeout(() => { if (notification.parentElement) notification.remove(); }, 5000);
}

// Fisher-Yates shuffle
function shuffle(array) {
    const a = [...array];
    for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
}

// Normalizza e filtra domande (placeholder, risposte incomplete, multiple corrette)
function normalizeQuestions(raw) {
    const placeholderRegex = /^\*+$|^\?+$/;
    return raw
        .filter(q => q && q.question && Array.isArray(q.answers))
        .map(q => ({
            question: String(q.question).trim(),
            answers: q.answers.filter(a => a && typeof a.text === 'string')
        }))
        .filter(q => q.answers.length === 4)
        .filter(q => {
            if (q.answers.some(a => placeholderRegex.test(a.text.trim()))) return false;
            const correctCount = q.answers.filter(a => a.correct === true).length;
            return correctCount === 1;
        });
}

// Override selezione casuale domande
function selectRandomQuestions(questions, count = 10) {
    const cleaned = normalizeQuestions(questions);
    const mixed = shuffle(cleaned);
    return mixed.slice(0, Math.min(count, mixed.length));
}

// Funzione per caricare le domande con retry mechanism
async function loadQuestions(retries = 3) {
    for (let i = 0; i < retries; i++) {
        try {
            const response = await fetch('questions.json');
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            if (!Array.isArray(data) || data.length === 0) throw new Error('Dati del quiz non validi');
            const validQuestions = data.filter(q => q.question && Array.isArray(q.answers));
            allQuestions = normalizeQuestions(validQuestions);
            if (allQuestions.length < 10) {
                console.warn('Numero domande valide inferiore a 10, il quiz user√† tutte le disponibili:', allQuestions.length);
            }
            startButton.disabled = false;
            startButton.innerText = 'Inizia';
            // Tentativo ripristino stato
            const saved = QuizState.load();
            if (saved && saved.selectedQuestions && saved.selectedQuestions.length) {
                const resume = confirm('Hai un quiz interrotto. Vuoi riprendere da dove avevi lasciato?');
                if (resume) {
                    selectedQuestions = saved.selectedQuestions;
                    currentQuestionIndex = saved.currentQuestionIndex;
                    score = saved.score || 0;
                    userAnswers = saved.userAnswers || [];
                    startScreen.classList.add('hidden');
                    quizScreen.classList.remove('hidden');
                    setNextQuestion();
                    updateProgress();
                    showNotification('Quiz ripristinato.', 'info');
                    return;
                } else {
                    QuizState.clear();
                }
            }
            return;
        } catch (err) {
            console.error(`Tentativo ${i + 1} fallito:`, err);
            if (i === retries - 1) {
                startButton.innerText = 'Riprova';
                startButton.disabled = false;
                startButton.onclick = () => {
                    startButton.disabled = true;
                    startButton.innerText = 'Caricamento...';
                    loadQuestions();
                };
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.innerHTML = `
                    <h3>‚ö†Ô∏è Errore di Caricamento</h3>
                    <p>Impossibile caricare le domande del quiz.</p>
                    <p><strong>Dettagli:</strong> ${err.message}</p>
                    <button class="btn error-retry-btn">üîÑ Ricarica Pagina</button>
                `;
                errorDiv.querySelector('.error-retry-btn').addEventListener('click', () => location.reload());
                const container = document.getElementById('start-screen');
                container.appendChild(errorDiv);
                return;
            }
            await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        }
    }
}

// Carica le domande al caricamento della pagina
loadQuestions();

// Gestione della navigazione da tastiera
document.addEventListener('keydown', function(e) {
    // Durante il quiz
    if (!quizScreen.classList.contains('hidden')) {
        const buttons = Array.from(answerButtonsElement.children);
        const activeElement = document.activeElement;
        const currentIndex = buttons.indexOf(activeElement);
        
        switch(e.key) {
            case 'ArrowDown':
            case 'ArrowRight':
                e.preventDefault();
                if (currentIndex < buttons.length - 1) {
                    buttons[currentIndex + 1].focus();
                } else {
                    buttons[0].focus();
                }
                break;
            case 'ArrowUp':
            case 'ArrowLeft':
                e.preventDefault();
                if (currentIndex > 0) {
                    buttons[currentIndex - 1].focus();
                } else {
                    buttons[buttons.length - 1].focus();
                }
                break;
            case 'Enter':
            case ' ':
                e.preventDefault();
                if (buttons.includes(activeElement) && !activeElement.disabled) {
                    activeElement.click();
                }
                break;
            case 'Escape':
                if (confirm('Vuoi davvero uscire dal quiz? Il progresso andr√† perso.')) {
                    startGame(); // Ricomincia
                }
                break;
        }
    }
    
    // Durante la revisione
    if (!reviewScreen.classList.contains('hidden')) {
        switch(e.key) {
            case 'ArrowLeft':
                e.preventDefault();
                if (!reviewPrevButton.disabled) {
                    reviewPrevButton.click();
                }
                break;
            case 'ArrowRight':
                e.preventDefault();
                if (!reviewNextButton.disabled) {
                    reviewNextButton.click();
                }
                break;
            case 'Escape':
                reviewExitButton.click();
                break;
        }
    }
});

startButton.addEventListener('click', startGame);
nextButton.addEventListener('click', () => {
    currentQuestionIndex++;
    setNextQuestion();
});
restartButton.addEventListener('click', () => {
    if (confirm('Sei sicuro di voler ricominciare? Il progresso attuale andr√† perso.')) {
        QuizState.clear();
        startGame();
    }
});
reviewButton.addEventListener('click', startReview);
reviewPrevButton.addEventListener('click', () => {
    if (reviewIndex > 0) {
        reviewIndex--;
        showReviewQuestion();
    }
});
reviewNextButton.addEventListener('click', () => {
    if (reviewIndex < userAnswers.length - 1) {
        reviewIndex++;
        showReviewQuestion();
    }
});
reviewExitButton.addEventListener('click', () => {
    reviewScreen.classList.add('hidden');
    resultScreen.classList.remove('hidden');
    // Focus sul pulsante restart quando si torna ai risultati
    setTimeout(() => restartButton.focus(), 100);
});

// Gestione dell'uscita dalla pagina durante il quiz
window.addEventListener('beforeunload', function(e) {
    // Avvisa solo se il quiz √® in corso
    if (!quizScreen.classList.contains('hidden') && currentQuestionIndex > 0) {
        e.preventDefault();
        e.returnValue = 'Hai un quiz in corso. Sei sicuro di voler uscire?';
        return e.returnValue;
    }
});

// Preferenze UI
const PREF_KEY = 'quiz-dialetti-preferences';
const themeToggleBtn = document.getElementById('theme-toggle');
const contrastToggleBtn = document.getElementById('contrast-toggle');
const fontIncBtn = document.getElementById('font-inc');
const fontDecBtn = document.getElementById('font-dec');
const fontResetBtn = document.getElementById('font-reset');
const printBtn = document.getElementById('print-btn');
let fontScaleLevel = 2; // 1..5

function loadPreferences() {
    try {
        const raw = localStorage.getItem(PREF_KEY);
        if (!raw) return;
        const pref = JSON.parse(raw);
        if (pref.theme === 'dark') document.body.classList.add('theme-dark');
        if (pref.contrast === true) document.body.classList.add('theme-contrast');
        if (pref.fontScale && pref.fontScale >=1 && pref.fontScale <=5) {
            fontScaleLevel = pref.fontScale;
            applyFontScale();
        }
        updatePrefButtons();
    } catch(e) { console.warn('Preferenze non caricate', e); }
}
function savePreferences() {
    const pref = {
        theme: document.body.classList.contains('theme-dark') ? 'dark' : 'light',
        contrast: document.body.classList.contains('theme-contrast'),
        fontScale: fontScaleLevel
    };
    try { localStorage.setItem(PREF_KEY, JSON.stringify(pref)); } catch(e) {}
}
function updatePrefButtons() {
    if (themeToggleBtn) themeToggleBtn.setAttribute('aria-pressed', document.body.classList.contains('theme-dark'));
    if (contrastToggleBtn) contrastToggleBtn.setAttribute('aria-pressed', document.body.classList.contains('theme-contrast'));
    if (themeToggleBtn) themeToggleBtn.textContent = document.body.classList.contains('theme-dark') ? 'Tema Chiaro' : 'Tema Scuro';
    if (contrastToggleBtn) contrastToggleBtn.textContent = document.body.classList.contains('theme-contrast') ? 'Contrasto Normale' : 'Alto Contrasto';
}
function applyFontScale() {
    document.documentElement.classList.remove('font-scale-1','font-scale-2','font-scale-3','font-scale-4','font-scale-5');
    document.documentElement.classList.add(`font-scale-${fontScaleLevel}`);
}
if (themeToggleBtn) themeToggleBtn.addEventListener('click', () => { document.body.classList.toggle('theme-dark'); updatePrefButtons(); savePreferences(); });
if (contrastToggleBtn) contrastToggleBtn.addEventListener('click', () => { document.body.classList.toggle('theme-contrast'); updatePrefButtons(); savePreferences(); });
if (fontIncBtn) fontIncBtn.addEventListener('click', () => { if (fontScaleLevel < 5) { fontScaleLevel++; applyFontScale(); savePreferences(); }});
if (fontDecBtn) fontDecBtn.addEventListener('click', () => { if (fontScaleLevel > 1) { fontScaleLevel--; applyFontScale(); savePreferences(); }});
if (fontResetBtn) fontResetBtn.addEventListener('click', () => { fontScaleLevel = 2; applyFontScale(); savePreferences(); });
if (printBtn) printBtn.addEventListener('click', () => { window.print(); });
// Abilita stampa solo a risultati visibili
const observer = new MutationObserver(() => {
    if (printBtn) {
        const canPrint = !resultScreen.classList.contains('hidden');
        printBtn.disabled = !canPrint;
    }
});
observer.observe(resultScreen, { attributes:true, attributeFilter:['class'] });
loadPreferences();

// Estensione updateProgress per aggiornare barra percentuale
function updateProgress() {
    if (progressText && selectedQuestions.length) {
        const current = Math.min(currentQuestionIndex + 1, selectedQuestions.length);
        progressText.textContent = `Domanda ${current} di ${selectedQuestions.length}`;
        const percent = ((current - 1) / selectedQuestions.length) * 100;
        const wrapper = document.getElementById('progress-wrapper');
        if (wrapper) {
            wrapper.style.setProperty('--progress-percent', percent + '%');
        }
    }
}

function startGame() {
    score = 0;
    userAnswers = [];
    startScreen.classList.add('hidden');
    resultScreen.classList.add('hidden');
    reviewScreen.classList.add('hidden');
    quizScreen.classList.remove('hidden');
    selectedQuestions = selectRandomQuestions(allQuestions, 10);
    currentQuestionIndex = 0;
    QuizState.clear();
    setNextQuestion();
    updateProgress();
    setTimeout(() => {
        const firstButton = answerButtonsElement.querySelector('.btn');
        if (firstButton) firstButton.focus();
    }, 100);
    showNotification('Quiz avviato! Usa le frecce per navigare tra le risposte.', 'success');
}

function setNextQuestion() {
    resetState();
    if (selectedQuestions.length > currentQuestionIndex) {
        showQuestion(selectedQuestions[currentQuestionIndex]);
        updateProgress();
    } else {
        showResult();
    }
}

// Funzione per sanitizzare il testo e prevenire XSS
function sanitizeText(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function showQuestion(question) {
    questionElement.textContent = question.question; // Usa textContent per sicurezza
    question.answers.forEach(answer => {
        const button = document.createElement('button');
        const span = document.createElement('span');
        span.textContent = sanitizeText(answer.text); // Sanitizza il testo
        button.appendChild(span);
        button.classList.add('btn');
        button.setAttribute('role', 'button');
        button.setAttribute('aria-label', `Risposta: ${answer.text}`);
        if (answer.correct) {
            button.dataset.correct = answer.correct;
        }
        button.addEventListener('click', selectAnswer);
        answerButtonsElement.appendChild(button);
    });
}

function resetState() {
    clearStatusClass(document.body);
    nextButton.classList.add('hidden');
    
    // Pulisce gli effetti LED e tutti i pulsanti precedenti
    while (answerButtonsElement.firstChild) {
        const button = answerButtonsElement.firstChild;
        if (button && button.classList) {
            button.classList.remove('selected-answer', 'correct', 'wrong');
        }
        answerButtonsElement.removeChild(button);
    }
}

function selectAnswer(e) {
    const selectedButton = e.target.closest('button'); // Usa closest per gestire il click su span
    const correct = selectedButton.dataset.correct === 'true';
    
    // Aggiungi effetto LED alla risposta selezionata
    selectedButton.classList.add('selected-answer');
    
    // Salva la risposta dell'utente con tutti i dettagli della domanda
    userAnswers.push({
        question: selectedQuestions[currentQuestionIndex].question,
        answers: selectedQuestions[currentQuestionIndex].answers,
        userAnswer: selectedButton.querySelector('span').textContent, // Prendi il testo dallo span
        userAnswerIndex: Array.from(answerButtonsElement.children).indexOf(selectedButton),
        correctAnswer: selectedQuestions[currentQuestionIndex].answers.find(ans => ans.correct).text,
        isCorrect: correct
    });
    
    if (correct) {
        score++;
        showNotification('Risposta corretta! üéâ', 'success');
    } else {
        showNotification('Risposta sbagliata üòî', 'error');
    }
    
    setStatusClass(selectedButton, correct);
    Array.from(answerButtonsElement.children).forEach(button => {
        setStatusClass(button, button.dataset.correct === 'true');
        button.disabled = true;
    });
    
    // Salva lo stato dopo ogni risposta
    QuizState.save();
    
    nextButton.classList.remove('hidden');
    nextButton.focus(); // Focus sul pulsante "Prossima"
}

function setStatusClass(element, correct) {
    clearStatusClass(element);
    if (correct) {
        element.classList.add('correct');
    } else {
        element.classList.add('wrong');
    }
}

function clearStatusClass(element) {
    element.classList.remove('correct');
    element.classList.remove('wrong');
}

function updateProgress() {
    if (progressText && selectedQuestions.length) {
        const cur = Math.min(currentQuestionIndex + 1, selectedQuestions.length);
        progressText.textContent = `Domanda ${cur} di ${selectedQuestions.length}`;
    }
}

function showResult() {
    quizScreen.classList.add('hidden');
    resultScreen.classList.remove('hidden');
    scoreElement.textContent = `${score} su ${selectedQuestions.length}`;
    const announcement = score >= Math.round(selectedQuestions.length * 0.7) ? 
        `Complimenti! Hai ottenuto ${score} punti su ${selectedQuestions.length}. Ottimo risultato!` :
        score >= Math.round(selectedQuestions.length * 0.5) ?
        `Hai ottenuto ${score} punti su ${selectedQuestions.length}. Buon risultato!` :
        `Hai ottenuto ${score} punti su ${selectedQuestions.length}. Puoi migliorare!`;
    showNotification(announcement, score >= Math.round(selectedQuestions.length * 0.7) ? 'success' : score >= Math.round(selectedQuestions.length * 0.5) ? 'info' : 'error');
    QuizState.clear();
    const summaryContainer = document.getElementById('answers-summary');
    summaryContainer.innerHTML = '';
    userAnswers.forEach((answer) => {
        const summaryItem = document.createElement('div');
        summaryItem.className = 'summary-item';
        const questionText = document.createElement('div');
        questionText.className = 'summary-question';
        questionText.textContent = answer.question.replace(/\n/g, ' ');
        const userAnswerDiv = document.createElement('div');
        userAnswerDiv.className = `summary-answer user-answer ${answer.isCorrect ? 'correct' : 'wrong'}`;
        userAnswerDiv.innerHTML = `<strong>La tua risposta:</strong> ${sanitizeText(answer.userAnswer)}`;
        summaryItem.appendChild(questionText);
        summaryItem.appendChild(userAnswerDiv);
        if (!answer.isCorrect) {
            const correctAnswerDiv = document.createElement('div');
            correctAnswerDiv.className = 'summary-answer correct-answer';
            correctAnswerDiv.innerHTML = `<strong>Risposta corretta:</strong> ${sanitizeText(answer.correctAnswer)}`;
            summaryItem.appendChild(correctAnswerDiv);
        }
        summaryContainer.appendChild(summaryItem);
    });
    setTimeout(() => restartButton.focus(), 100);
}

function startReview() {
    reviewIndex = 0;
    resultScreen.classList.add('hidden');
    reviewScreen.classList.remove('hidden');
    showReviewQuestion();
}

function showReviewQuestion() {
    const currentAnswer = userAnswers[reviewIndex];
    
    // Aggiorna il contatore
    reviewCounterElement.textContent = `${reviewIndex + 1} di ${userAnswers.length}`;
    
    // Mostra la domanda
    reviewQuestionElement.textContent = currentAnswer.question;
    
    // Pulisce le risposte precedenti
    reviewAnswersElement.innerHTML = '';
    
    // Crea i pulsanti delle risposte
    currentAnswer.answers.forEach((answer, index) => {
        const button = document.createElement('button');
        const span = document.createElement('span');
        span.textContent = sanitizeText(answer.text); // Sanitizza il testo
        button.appendChild(span);
        button.classList.add('btn');
        button.disabled = true; // Non cliccabili in modalit√† revisione
        button.setAttribute('role', 'button');
        button.setAttribute('aria-label', `Risposta ${index + 1}: ${answer.text}`);
        
        // Evidenzia la risposta dell'utente e quella corretta
        if (index === currentAnswer.userAnswerIndex) {
            // Risposta selezionata dall'utente
            button.classList.add('user-selected');
            button.setAttribute('aria-label', `La tua risposta: ${answer.text}`);
            if (currentAnswer.isCorrect) {
                button.classList.add('correct');
                button.setAttribute('aria-label', `La tua risposta corretta: ${answer.text}`);
            } else {
                button.classList.add('wrong');
                button.setAttribute('aria-label', `La tua risposta sbagliata: ${answer.text}`);
            }
        } else if (answer.correct) {
            // Risposta corretta (se diversa da quella dell'utente)
            button.classList.add('correct');
            button.setAttribute('aria-label', `Risposta corretta: ${answer.text}`);
        }
        
        reviewAnswersElement.appendChild(button);
    });
    
    // Gestisce i pulsanti di navigazione
    reviewPrevButton.disabled = (reviewIndex === 0);
    reviewNextButton.disabled = (reviewIndex === userAnswers.length - 1);
}

// Analitiche Locali (evento serale semplice)
const ANALYTICS_KEY = 'quiz-dialetti-analytics';
let analytics = { sessions: [], answers: [] };
let sessionStartTs = null;
let currentSessionId = null;

function loadAnalytics() {
  try { const raw = localStorage.getItem(ANALYTICS_KEY); if (raw) analytics = JSON.parse(raw); } catch(e) {}
}
function saveAnalytics() { try { localStorage.setItem(ANALYTICS_KEY, JSON.stringify(analytics)); } catch(e) {} }
function startAnalyticsSession(questionCount) {
  sessionStartTs = performance.now();
  currentSessionId = Date.now().toString(36);
  analytics.sessions.push({ id: currentSessionId, startedAt: Date.now(), questionCount, finished: false, durationMs: null, score: null });
  saveAnalytics();
}
function recordAnswerAnalytics(questionObj, isCorrect, timeMs) {
  analytics.answers.push({ sid: currentSessionId, q: questionObj.question.slice(0,120), correct: isCorrect, ms: Math.round(timeMs) });
  saveAnalytics();
}
function endAnalyticsSession(finalScore) {
  const s = analytics.sessions.find(s => s.id === currentSessionId);
  if (s && !s.finished) {
    s.finished = true; s.durationMs = Math.round(performance.now() - sessionStartTs); s.score = finalScore; saveAnalytics();
  }
  currentSessionId = null;
}
loadAnalytics();

// Override startGame to integrate analytics (wrapped later if needed)
const _originalStartGame = startGame;
startGame = function() {
  _originalStartGame();
  startAnalyticsSession(selectedQuestions.length);
  lastQuestionStart = performance.now();
};

let lastQuestionStart = null;

// Patch selectAnswer per misurare tempo
const _originalSelectAnswer = selectAnswer;
selectAnswer = function(e) {
  const now = performance.now();
  const elapsed = lastQuestionStart ? now - lastQuestionStart : 0;
  _originalSelectAnswer(e);
  recordAnswerAnalytics(selectedQuestions[currentQuestionIndex], userAnswers[userAnswers.length-1].isCorrect, elapsed);
};

// Patch setNextQuestion per aggiornare lastQuestionStart
const _originalSetNextQuestion = setNextQuestion;
setNextQuestion = function() { _originalSetNextQuestion(); lastQuestionStart = performance.now(); };

// Patch showResult per chiusura sessione + render analytics se aperto
const _originalShowResult = showResult;
showResult = function() {
  _originalShowResult();
  endAnalyticsSession(score);
  if (!document.getElementById('analytics-panel').classList.contains('hidden')) {
    renderAnalytics();
  }
};

// Rendering Analytics
function computeAnalytics() {
  const totalSessions = analytics.sessions.length;
  const completed = analytics.sessions.filter(s => s.finished);
  const avgScore = completed.length ? (completed.reduce((a,b)=>a+(b.score||0),0)/completed.length) : 0;
  const avgDuration = completed.length ? (completed.reduce((a,b)=>a+(b.durationMs||0),0)/completed.length) : 0;
  const answerGroups = analytics.answers.reduce((map,a)=>{ const key=a.q; if(!map[key]) map[key]={q:key, attempts:0, correct:0, totalMs:0}; map[key].attempts++; if(a.correct) map[key].correct++; map[key].totalMs += a.ms; return map; }, {});
  const difficulty = Object.values(answerGroups)
    .map(o => ({
      question:o.q,
      attempts:o.attempts,
      accuracy: o.correct / o.attempts,
      avgMs: o.totalMs / o.attempts
    }))
    .filter(o => o.attempts >= 1)
    .sort((a,b)=> a.accuracy - b.accuracy) // from hardest to easiest by accuracy
    .slice(0,5);
  return { totalSessions, completed: completed.length, avgScore, avgDuration, difficulty };
}

function formatMs(ms) { if (!ms) return '-'; const s = ms/1000; if (s < 60) return s.toFixed(1)+'s'; const m=Math.floor(s/60); const rs=(s%60).toFixed(0); return `${m}m ${rs}s`; }

function renderAnalytics() {
  const stats = computeAnalytics();
  const container = document.getElementById('analytics-content');
  if (!container) return;
  container.innerHTML = '';
  // Metrics cards
  const cards = [
    { title:'Sessioni Totali', value: stats.totalSessions },
    { title:'Sessioni Concluse', value: stats.completed },
    { title:'Punteggio Medio', value: stats.avgScore.toFixed(2) },
    { title:'Durata Media', value: formatMs(stats.avgDuration) }
  ];
  cards.forEach(c => {
    const div = document.createElement('div');
    div.className='analytics-card';
    div.innerHTML = `<h3>${c.title}</h3><div class="analytics-metric">${c.value}</div>`;
    container.appendChild(div);
  });
  // Difficili
  const diffWrapper = document.createElement('div');
  diffWrapper.className='analytics-card';
  diffWrapper.innerHTML = '<h3>Domande Pi√π Difficili</h3>';
  if (!stats.difficulty.length) {
    diffWrapper.innerHTML += '<div class="analytics-small">Nessun dato ancora.</div>';
  } else {
    const table = document.createElement('table');
    table.className='analytics-table';
    table.innerHTML = '<thead><tr><th>Domanda (troncata)</th><th>Accuratezza</th><th>Tentativi</th><th>T. Medio</th></tr></thead>';
    const tbody = document.createElement('tbody');
    stats.difficulty.forEach(d => {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${sanitizeText(d.question)}</td><td>${(d.accuracy*100).toFixed(0)}%</td><td>${d.attempts}</td><td>${formatMs(d.avgMs)}</td>`;
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    diffWrapper.appendChild(table);
  }
  container.appendChild(diffWrapper);
}

// Toggle analytics panel
const analyticsToggle = document.getElementById('analytics-toggle');
const analyticsPanel = document.getElementById('analytics-panel');
const analyticsRefreshBtn = document.getElementById('analytics-refresh');
const analyticsResetBtn = document.getElementById('analytics-reset');
if (analyticsToggle && analyticsPanel) {
  analyticsToggle.addEventListener('click', () => {
    const hidden = analyticsPanel.classList.toggle('hidden');
    analyticsToggle.setAttribute('aria-expanded', (!hidden).toString());
    if (!hidden) { renderAnalytics(); window.scrollTo({ top: analyticsPanel.offsetTop - 20, behavior:'smooth'}); }
  });
}
if (analyticsRefreshBtn) analyticsRefreshBtn.addEventListener('click', () => renderAnalytics());
if (analyticsResetBtn) analyticsResetBtn.addEventListener('click', () => { if (confirm('Reset analitiche locali?')) { analytics = { sessions: [], answers: [] }; saveAnalytics(); renderAnalytics(); }});

// Global progress bar update (lightweight)
const globalProgressBar = document.getElementById('global-progress-bar');
const _originalUpdateProgress = updateProgress;
updateProgress = function() {
  _originalUpdateProgress();
  if (globalProgressBar && selectedQuestions.length) {
    const current = Math.min(currentQuestionIndex, selectedQuestions.length);
    const percent = (current / selectedQuestions.length) * 100;
    globalProgressBar.style.width = percent + '%';
  }
};
